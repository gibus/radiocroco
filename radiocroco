#!/usr/bin/perl

use strict;
use warnings;

use Glib qw(TRUE FALSE);
use GStreamer '-init';
use GStreamer::Interfaces;
use Gtk2 '-init';
use Data::Dumper;
use FindBin qw($RealBin);

# Global variables
my $stream_url = 'https://radiocroco.info/streaming/radiocroco_64.mp3'; # Stream url from radiocroco.info
my $window; # GTK top level window
my $player; # GStreamer playerbin2 pipeline
my $vis; # GStreamer visualization plugin (goom2k)
my $canvas; # Canvas to display music visalization when playing or static image otherwise
my $status; # Status label widget
my $play_stop_button; # Togglable button
my $play_stop_status = 1; # Status of togglable button (play=1/stop=0)
my $pixbuf = Gtk2::Gdk::Pixbuf->new_from_file("$RealBin/radiocroco.png"); # Static image

# Gstreamer bus callback
sub bus_callback {
  my ($bus, $message, $loop) = @_;

  if ($message->type & 'eos') {
    $loop -> quit();
  }

  elsif ($message->type & 'error') {
    $loop -> quit();
  }
  else {
    my $struct = $message->get_structure;
    if ($struct && $struct->{name} eq 'playbin2-stream-changed') {
      my $vis_sink = $player->get_by_name('videosink-actual-sink-xvimage');
      if ($vis_sink) {
        $vis_sink->set_xwindow_id($canvas->window->get_xid);
      }
      $status->set_label('Playing');
    }
  }
  return TRUE;
}

# Play/Stop handler
sub play_stop {
  # Toggle status
  $play_stop_status = not $play_stop_status;

  # Play
  if ($play_stop_status) {
    $player->set_state('playing');
    $status->set_label('Connecting to stream...');
    $play_stop_button->set_label('Stop');
    # Dirty hack if window was previously resized
    $window->resize(320, 408);
  }
  # Stop
  else {
    $player->set_state('ready');
    $status->set_label('Stopped');
    $play_stop_button->set_label('Play');
    # Dirty hack to clear window
    $window->unmaximize;
    $window->resize(321, 408);
  }
}

# Display static image when not playing
sub canvas_expose {
  my $area = shift;
  my $event = shift;
  if ($status->get_label ne 'Playing') {
    my $gc = Gtk2::Gdk::GC->new($canvas->get_window);
    $area->get_window->draw_pixbuf($gc, $pixbuf, 0, 0, (($event->area->width - $pixbuf->get_width) / 2), (($event->area->height - $pixbuf->get_height) / 2), -1, -1, 'none', 0, 0);
  }
}

# Create the main loop and pipeline
my $loop = Glib::MainLoop->new(undef, FALSE);
($player, $vis) = GStreamer::ElementFactory->make('playbin2' => 'player', 'goom2k1' => 'vis');
$player->set('vis-plugin', $vis);
$player->set('flags', ['video', 'audio', 'text', 'soft-volume', 'vis', 'download', 'buffering']);

# Create container widgets
$window = Gtk2::Window->new('toplevel');
$window->set_title("Radio Croco");
$window->set_icon($pixbuf);
my $vbox = Gtk2::VBox->new(FALSE, 10);
my $buttons = Gtk2::HButtonBox->new;

# Add a label
my $label = Gtk2::Label->new("Radio Croco");
$vbox->pack_start($label, FALSE, FALSE, 10);

# Add canvas for vizualization plugin
$canvas = Gtk2::DrawingArea->new;
$canvas->size(320, 240);
$vbox->pack_start($canvas, TRUE, TRUE, 10);

# Add a status label
$status = Gtk2::Label->new("Connecting to stream...");
$vbox->pack_start($status, FALSE, FALSE, 0);

# Add stream url as text entry
my $text = Gtk2::Entry->new;
$text->set_text($stream_url);
$text->set_editable(FALSE);
$vbox->pack_start($text, FALSE, FALSE, 0);

# Playback controls
$vbox->pack_start($buttons, FALSE, TRUE, 0);

# Display window
$window->add($vbox);
$window->signal_connect(delete_event => sub {$player->set_state('null'); exit;});
$window->show_all;

# Display static image when not playing
$canvas->signal_connect (expose_event => \&canvas_expose);

# Set player source to stream URI
$player->set(uri => $stream_url);

# Play/Stop button
$play_stop_button = Gtk2::Button->new('Stop');
$play_stop_button->signal_connect(clicked => \&play_stop);
$buttons->add($play_stop_button);
$play_stop_button->show_all;

# Exit button
my $exit_button = Gtk2::Button->new('Exit');
$exit_button->signal_connect(clicked => sub {$player->set_state('null'); exit;});
$buttons->add($exit_button);
$exit_button->show_all;

# Set bus callback to detect when visualization sink is created
$player->get_bus->add_watch(\&bus_callback, $loop);

# Play stream
$player->set_state('playing');

# Run the program
$loop->run;

# Cleanup
$player->set_state('null');
