#!/usr/bin/perl

use strict;
use warnings;

use LWP::UserAgent;
use JSON;
use Glib qw(TRUE FALSE filename_to_uri);
use GStreamer '-init';
use GStreamer::Interfaces;
use Gtk2 '-init';
use File::Spec;
use Cwd;
use Data::Dumper;

# Fetch mixlr radiocroco page
my $ua = LWP::UserAgent->new(env_proxy => 1);
my $src_req = $ua->get('http://api.mixlr.com/users/radiocroco?source=embed&callback=onUserLoad');
unless ($src_req->is_success or $src_req->is_redirect) {
  die "Error in fetch source request: !" . $src_req->message . "! code=!" . $src_req->code . "!\n";
}

# Extract stream url
(my $src_json) = $src_req->content =~ /onUserLoad\(([^\)]+)\);/o;
unless (defined $src_json) {
  die "Error in source content: !" . $src_req->content . "!\n";
}
my $src = decode_json($src_json);
unless (defined $src) {
  die "Error in source json !$src_json!\n";
}
my $stream_url = $src->{broadcasts}->[0]->{streams}->{rtsp}->{url};
unless (defined $stream_url) {
  die "Error in source !" . Dumper($src) . "!\n";
}

# Create the main pipeline and GUI elements
my $pipeline = GStreamer::Pipeline->new('pipeline');
my ($player, $goom) = GStreamer::ElementFactory->make(playbin => 'player', 'goom' => 'goom');
$pipeline->add($player);
$player->set('vis-plugin', $goom);

# Create the widgets
my $window = Gtk2::Window->new('toplevel');
$window->set_title("Radio Croco");

my $vbox = Gtk2::VBox->new(FALSE, 10);

# Add a label
my $label = Gtk2::Label->new("Radio Croco");
$vbox->pack_start($label, FALSE, FALSE, 0);

# Add stream url as text entry
my $text = Gtk2::Entry->new();
$text->set_text("Stream from $stream_url");
$text->set_editable(FALSE);
$text->set_width_chars(length($stream_url) + 12);
$vbox->pack_start($text, FALSE, FALSE, 0);

# Prepare a box that will hold the playback controls
my $buttons = Gtk2::HButtonBox->new();
$vbox->pack_start($buttons, FALSE, TRUE, 0);

$window->add($vbox);

$window->signal_connect(delete_event => sub {Gtk2->main_quit(); return Glib::SOURCE_CONTINUE;});

$window->show_all();

$player->set(uri => $stream_url);

# Play at start
$pipeline->set_state('playing');
# Store status (play=1/stop=0)
my $play_stop_status = 1;

# Play/Stop button
my $play_stop_button = Gtk2::Button->new('Stop');

# Play/Stop handler
sub play_stop {
  # Toggle status
  $play_stop_status = not $play_stop_status;

  # Play
  if ($play_stop_status) {
    $pipeline->set_state('playing');
    $play_stop_button->set_label('Stop');
  }
  # Stop
  else {
    $pipeline->set_state('ready');
    $play_stop_button->set_label('Play');
  }
}

$play_stop_button->signal_connect(clicked => \&play_stop);
$buttons->add($play_stop_button);
$play_stop_button->show_all();

# Exit button
my $exit_button = Gtk2::Button->new('Exit');
$exit_button->signal_connect(clicked => sub {Gtk2->main_quit(); return Glib::SOURCE_CONTINUE;});
$buttons->add($exit_button);
$exit_button->show_all();

# Run the program
Gtk2->main();

# Cleanup
$pipeline->set_state('null');
