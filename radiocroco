#!/usr/bin/perl

use strict;
use warnings;

use Glib qw(TRUE FALSE);
use GStreamer '-init';
use GStreamer::Interfaces;
use Gtk2 '-init';
use Data::Dumper;

# Stream url from radiocroco.info
my $stream_url = 'https://radiocroco.info/streaming/radiocroco_64.mp3';

# Create the main loop and pipeline
my $loop = Glib::MainLoop->new(undef, FALSE);
my $pipeline = GStreamer::Pipeline->new('pipeline');
my ($player, $vis) = GStreamer::ElementFactory->make('playbin2' => 'player', 'goom2k1' => 'goom');
$player->set('vis-plugin', $vis);
$player->set('async-handling', TRUE);
$player->set('flags', ['video', 'audio', 'text', 'soft-volume', 'vis', 'download', 'buffering']);
$pipeline->add($player);

# Create the widgets
my $window = Gtk2::Window->new('toplevel');
$window->set_title("Radio Croco");
my $vbox = Gtk2::VBox->new(FALSE, 10);

# Add a label
my $label = Gtk2::Label->new("Radio Croco");
$vbox->pack_start($label, FALSE, FALSE, 0);

# Add canvas for vizualization plugin
my $canvas = Gtk2::DrawingArea->new();
$canvas->set_size_request(320, 240);
$vbox->pack_start($canvas, FALSE, TRUE, 10);

# Add a status label
my $status = Gtk2::Label->new("Connecting to stream...");
$vbox->pack_start($status, FALSE, FALSE, 0);

# Add stream url as text entry
my $text = Gtk2::Entry->new();
$text->set_text($stream_url);
$text->set_editable(FALSE);
$vbox->pack_start($text, FALSE, FALSE, 0);

# Playback controls
my $buttons = Gtk2::HButtonBox->new();
$vbox->pack_start($buttons, FALSE, TRUE, 0);

$window->add($vbox);
$window->signal_connect(delete_event => sub {$pipeline->set_state('null'); exit;});
$window->show_all();

# Set player source to stream URI
$player->set(uri => $stream_url);

# Play/Stop button
my $play_stop_button = Gtk2::Button->new('Stop');

$play_stop_button->signal_connect(clicked => \&play_stop);
$buttons->add($play_stop_button);
$play_stop_button->show_all();

# Exit button
my $exit_button = Gtk2::Button->new('Exit');
$exit_button->signal_connect(clicked => sub {$pipeline->set_state('null'); exit;});
$buttons->add($exit_button);
$exit_button->show_all();

# Set bus callback to detect when visualization sink is created
$pipeline->get_bus()->add_watch(\&bus_callback, $loop);

# Play stream
$pipeline->set_state('playing');

# Store status (play=1/stop=0)
my $play_stop_status = 1;

# Run the program
$loop->run();

# Cleanup
$pipeline->set_state('null');

# Play/Stop handler
sub play_stop {
  # Toggle status
  $play_stop_status = not $play_stop_status;

  # Play
  if ($play_stop_status) {
    $pipeline->set_state('playing');
    $status->set_label('Connecting to stream...');
    $play_stop_button->set_label('Stop');
  }
  # Stop
  else {
    $pipeline->set_state('ready');
    $status->set_label('Stopped');
    $play_stop_button->set_label('Play');
  }
}

# Bus callback
sub bus_callback {
  my ($bus, $message, $loop) = @_;

  my $struct = $message->get_structure;
  if ($struct && $struct->{name} eq 'playbin2-stream-changed') {
    my $vis_sink = $pipeline->get_by_name('videosink-actual-sink-xvimage');
    if ($vis_sink) {
      $vis_sink->set_xwindow_id($canvas->window->get_xid);
    }
    $status->set_label('Playing');
  }
  return TRUE;
}
